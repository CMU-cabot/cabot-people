import sys
from std_msgs.msg import ColorRGBA

class Colors(object):
    # This class assigns colors to the markers for visualization purposes

    def __init__(self, values=None):
        if values is None:
            values = [0.0, 1.0]
        for v in values:
            if (not isinstance(v, float)) or (v < 0.0) or (v > 1.0):
                raise Exception("Color values must be 0.0 - 1.0")
                sys.exit(0)
        self.color_palette = self._generate_palette(values)
        self.num_colors = len(self.color_palette)

    def _generate_palette(self, values):
        palette = []
        for i in values:
            for j in values:
                for k in values:
                    palette.append([i, j, k])
        return palette

    def get_color(self, seed, fixed=None):
        if fixed is None:
            idx = seed % self.num_colors
            color = self.color_palette[idx]
        else:
            if not (fixed >= 0 and fixed < self.num_colors):
                print("Available colors are")
                print(self.color_palette)
                raise Exception("Color indexes are from 0 to {}".format(self.num_colors))
                sys.exit(0)
            color = self.color_palette[fixed]
        color_msg = ColorRGBA()
        color_msg.r = color[0]
        color_msg.g = color[1]
        color_msg.b = color[2]
        color_msg.a = 1.0
        return color_msg

# A simple queue implementation
# Generated by GPT-4o with modifications
class SimpleQueue:
    def __init__(self, max_size):
        """Initialize the queue with a maximum size."""
        self._items = []
        self._max_size = max_size

    def is_empty(self):
        """Check if the queue is empty."""
        return len(self._items) == 0

    def is_full(self):
        """Check if the queue is full."""
        return len(self._items) >= self._max_size

    def enqueue(self, item):
        """Add an item to the end of the queue.
        
        Raises:
            OverflowError: If the queue is full.
        """
        if self.is_full():
            raise OverflowError("Enqueue to a full queue")
        self._items.append(item)

    def dequeue(self):
        """Remove and return the item from the front of the queue.
        
        Raises:
            IndexError: If the queue is empty.
        """
        if self.is_empty():
            raise IndexError("Dequeue from an empty queue")
        return self._items.pop(0)

    def peek(self):
        """Return the item at the front of the queue without removing it.
        
        Raises:
            IndexError: If the queue is empty.
        """
        if self.is_empty():
            raise IndexError("Peek from an empty queue")
        return self._items[0]
    
    def peek_last(self):
        """Return the item at the end of the queue without removing it.
        
        Raises:
            IndexError: If the queue is empty.
        """
        if self.is_empty():
            raise IndexError("Peek from an empty queue")
        return self._items[-1]
    
    def swap_last(self, item):
        """Replace the last item in the queue with a new item.
        
        Raises:
            IndexError: If the queue is empty.
        """
        if self.is_empty():
            raise IndexError("Swap last in an empty queue")
        self._items[-1] = item
    
    def clear(self):
        """Clear all items from the queue."""
        self._items = []

    def size(self):
        """Return the number of items in the queue."""
        return len(self._items)

    def __str__(self):
        """Return a string representation of the queue."""
        return f"Queue({self.size()}/{self._max_size}): {self._items}"